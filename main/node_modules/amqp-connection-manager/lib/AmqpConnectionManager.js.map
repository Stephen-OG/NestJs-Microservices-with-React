{"version":3,"sources":["../src/AmqpConnectionManager.js"],"names":["HEARTBEAT_IN_SECONDS","neverThrows","err","setImmediate","Error","message","stack","AmqpConnectionManager","EventEmitter","constructor","urls","options","findServers","_channels","_currentUrl","connectionOptions","heartbeatIntervalInSeconds","reconnectTimeInSeconds","setMaxListeners","_findServers","Promise","resolve","_connect","createChannel","channel","ChannelWrapper","push","once","filter","c","close","_closed","_cancelRetriesHandler","_connectPromise","then","all","map","catch","_currentConnection","removeAllListeners","isConnected","_urls","length","pb","callFn","Array","isArray","url","urlString","amqpUrl","Object","assign","heartbeat","urlUtils","parse","search","format","amqp","connect","connection","on","reason","emit","handle","cancel","promise"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AAEA;;AACA;;AACA;;;;AAEA;AACA,MAAMA,oBAAoB,GAAG,CAA7B;AAEA;;AACA,SAASC,WAAT,GAAuB;AACnB,SAAOC,GAAG,IACNC,YAAY,CAAC,MAAM;AACf,UAAM,IAAIC,KAAJ,CAAW,kDAAiDF,GAAG,CAACG,OAAQ,IAA9D,GACZH,GAAG,CAACI,KADF,CAAN;AAEH,GAHW,CADhB;AAKH,C,CAED;AACA;AACA;AACA;AACA;;;AACe,MAAMC,qBAAN,SAAoCC,oBAApC,CAAiD;AAC5D;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,WAAW,CAACC,IAAD,EAAOC,OAAO,GAAG,EAAjB,EAAqB;AAC5B;;AACA,QAAG,CAACD,IAAD,IAAS,CAACC,OAAO,CAACC,WAArB,EAAkC;AAC9B,YAAM,IAAIR,KAAJ,CAAU,4CAAV,CAAN;AACH;;AACD,SAAKS,SAAL,GAAiB,EAAjB;AAEA,SAAKC,WAAL,GAAmB,CAAnB;AACA,SAAKC,iBAAL,GAAyBJ,OAAO,CAACI,iBAAjC;AAEA,SAAKC,0BAAL,GAAkCL,OAAO,CAACK,0BAAR,IAAsChB,oBAAxE;AACA,SAAKiB,sBAAL,GAA8BN,OAAO,CAACM,sBAAR,IAAkC,KAAKD,0BAArE,CAX4B,CAa5B;;AACA,SAAKE,eAAL,CAAqB,CAArB;;AAEA,SAAKC,YAAL,GAAoBR,OAAO,CAACC,WAAR,KAAwB,MAAMQ,OAAO,CAACC,OAAR,CAAgBX,IAAhB,CAA9B,CAApB;;AAEA,SAAKY,QAAL;AACH,GA3C2D,CA6C5D;;;AACAC,EAAAA,aAAa,CAACZ,OAAO,GAAG,EAAX,EAAe;AACxB,UAAMa,OAAO,GAAG,IAAIC,uBAAJ,CAAmB,IAAnB,EAAyBd,OAAzB,CAAhB;;AACA,SAAKE,SAAL,CAAea,IAAf,CAAoBF,OAApB;;AACAA,IAAAA,OAAO,CAACG,IAAR,CAAa,OAAb,EAAsB,MAAM;AACxB,WAAKd,SAAL,GAAiB,KAAKA,SAAL,CAAee,MAAf,CAAsBC,CAAC,IAAIA,CAAC,KAAKL,OAAjC,CAAjB;AACH,KAFD;AAGA,WAAOA,OAAP;AACH;;AAEDM,EAAAA,KAAK,GAAG;AACJ,QAAG,KAAKC,OAAR,EAAiB;AAAE,aAAOX,OAAO,CAACC,OAAR,EAAP;AAA2B;;AAC9C,SAAKU,OAAL,GAAe,IAAf;;AAEA,QAAG,KAAKC,qBAAR,EAA+B;AAC7B,WAAKA,qBAAL;;AACA,WAAKA,qBAAL,GAA6B,IAA7B;AACD;;AAED,WAAOZ,OAAO,CAACC,OAAR,CAAgB,KAAKY,eAArB,EAAsCC,IAAtC,CAA2C,MAAM;AACpD,aAAOd,OAAO,CAACe,GAAR,CAAY,KAAKtB,SAAL,CAAeuB,GAAf,CAAmBZ,OAAO,IAAIA,OAAO,CAACM,KAAR,EAA9B,CAAZ,EACNO,KADM,CACA,YAAW,CACd;AACH,OAHM,EAINH,IAJM,CAID,MAAM;AACR,aAAKrB,SAAL,GAAiB,EAAjB;;AACA,YAAG,KAAKyB,kBAAR,EAA4B;AACxB,eAAKA,kBAAL,CAAwBC,kBAAxB,CAA2C,OAA3C;;AACA,eAAKD,kBAAL,CAAwBR,KAAxB;AACH;;AACD,aAAKQ,kBAAL,GAA0B,IAA1B;AACH,OAXM,CAAP;AAYH,KAbM,CAAP;AAcH;;AAEDE,EAAAA,WAAW,GAAG;AACV,WAAO,CAAC,CAAC,KAAKF,kBAAd;AACH;;AAEDhB,EAAAA,QAAQ,GAAG;AACP,QAAI,KAAKW,eAAT,EAA0B;AACtB,aAAO,KAAKA,eAAZ;AACH;;AAED,QAAG,KAAKF,OAAL,IAAgB,KAAKS,WAAL,EAAnB,EAAuC;AACnC,aAAOpB,OAAO,CAACC,OAAR,EAAP;AACH;;AAED,SAAKY,eAAL,GAAuBb,OAAO,CAACC,OAAR,GACtBa,IADsB,CACjB,MAAM;AACR,UAAG,CAAC,KAAKO,KAAN,IAAgB,KAAK3B,WAAL,IAAoB,KAAK2B,KAAL,CAAWC,MAAlD,EAA2D;AACvD,aAAK5B,WAAL,GAAmB,CAAnB;AACA,eAAO6B,wBAAGC,MAAH,CAAU,KAAKzB,YAAf,EAA6B,CAA7B,EAAgC,IAAhC,CAAP;AACH,OAHD,MAGO;AACH,eAAO,KAAKsB,KAAZ;AACH;AACJ,KARsB,EAStBP,IATsB,CASjBxB,IAAI,IAAI;AACV,UAAGA,IAAI,IAAI,CAACmC,KAAK,CAACC,OAAN,CAAcpC,IAAd,CAAZ,EAAiC;AAAEA,QAAAA,IAAI,GAAG,CAACA,IAAD,CAAP;AAAgB;;AACnD,WAAK+B,KAAL,GAAa/B,IAAb;;AAEA,UAAG,CAACA,IAAD,IAAUA,IAAI,CAACgC,MAAL,KAAgB,CAA7B,EAAiC;AAC7B,cAAM,IAAItC,KAAJ,CAAU,2CAAV,CAAN;AACH,OANS,CAQV;;;AACA,YAAM2C,GAAG,GAAGrC,IAAI,CAAC,KAAKI,WAAN,CAAhB;AACA,WAAKA,WAAL,GAVU,CAYV;;AACA,YAAMkC,SAAS,GAAGD,GAAG,CAACA,GAAJ,IAAWA,GAA7B;AACA,YAAMhC,iBAAiB,GAAGgC,GAAG,CAAChC,iBAAJ,IAAyB,KAAKA,iBAAxD;AAEA,UAAIkC,OAAO,GAAG,IAAd;;AAEA,UAAG,OAAOD,SAAP,KAAqB,QAAxB,EAAkC;AAC9BC,QAAAA,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBJ,GAAlB,CAAV;;AACA,YAAG,CAACE,OAAO,CAACG,SAAZ,EAAuB;AACnBH,UAAAA,OAAO,CAACG,SAAR,GAAoB,KAAKpC,0BAAzB;AACH;AACJ,OALD,MAKM;AACFiC,QAAAA,OAAO,GAAGI,aAASC,KAAT,CAAeN,SAAf,CAAV;;AACA,YAAGC,OAAO,CAACM,MAAX,EAAmB;AACfN,UAAAA,OAAO,CAACM,MAAR,IAAmB,cAAa,KAAKvC,0BAA2B,EAAhE;AACH,SAFD,MAEO;AACHiC,UAAAA,OAAO,CAACM,MAAR,GAAkB,cAAa,KAAKvC,0BAA2B,EAA/D;AACH;;AACDiC,QAAAA,OAAO,GAAGI,aAASG,MAAT,CAAgBP,OAAhB,CAAV;AACH;;AAGD,aAAOQ,iBAAKC,OAAL,CAAaT,OAAb,EAAsBlC,iBAAtB,EACNmB,IADM,CACDyB,UAAU,IAAI;AAChB,aAAKrB,kBAAL,GAA0BqB,UAA1B,CADgB,CAGhB;;AACAA,QAAAA,UAAU,CAACC,EAAX,CAAc,SAAd,EAAyBC,MAAM,IAAI,KAAKC,IAAL,CAAU,SAAV,EAAqB;AAAED,UAAAA;AAAF,SAArB,CAAnC;AAEAF,QAAAA,UAAU,CAACC,EAAX,CAAc,WAAd,EAA2B,MAAM,KAAKE,IAAL,CAAU,WAAV,CAAjC;AAEAH,QAAAA,UAAU,CAACC,EAAX,CAAc,OAAd,EAAuB;AAAC;AAAc,SAClC;AACA;AACA;AACA;AACH,SALD,EARgB,CAehB;;AACAD,QAAAA,UAAU,CAACC,EAAX,CAAc,OAAd,EAAuB1D,GAAG,IAAI;AAC1B,eAAKoC,kBAAL,GAA0B,IAA1B;AACA,eAAKwB,IAAL,CAAU,YAAV,EAAwB;AAAE5D,YAAAA;AAAF,WAAxB;AAEA,gBAAM6D,MAAM,GAAG,mBAAK,KAAK9C,sBAAL,GAA8B,IAAnC,CAAf;AACA,eAAKe,qBAAL,GAA6B+B,MAAM,CAACC,MAApC;AAEAD,UAAAA,MAAM,CACHE,OADH,GAEG/B,IAFH,CAEQ,MAAM,KAAKZ,QAAL,EAFd,EAGE;AAHF,WAIGe,KAJH,CAISpC,WAJT;AAKH,SAZD;AAcA,aAAKgC,eAAL,GAAuB,IAAvB;AACA,aAAK6B,IAAL,CAAU,SAAV,EAAqB;AAAEH,UAAAA,UAAF;AAAcZ,UAAAA,GAAG,EAAEC;AAAnB,SAArB;AAEA,eAAO,IAAP;AACH,OAnCM,CAAP;AAoCH,KA/EsB,EAgFtBX,KAhFsB,CAgFhBnC,GAAG,IAAI;AACV,WAAK4D,IAAL,CAAU,YAAV,EAAwB;AAAE5D,QAAAA;AAAF,OAAxB,EADU,CAGV;;AACA,WAAKoC,kBAAL,GAA0B,IAA1B;AACA,WAAKL,eAAL,GAAuB,IAAvB,CALU,CAOV;;AACA,YAAM8B,MAAM,GAAG,mBAAK,KAAK9C,sBAAL,GAA8B,IAAnC,CAAf;AACA,WAAKe,qBAAL,GAA6B+B,MAAM,CAACC,MAApC;AAEA,aAAOD,MAAM,CAACE,OAAP,GAAiB/B,IAAjB,CAAsB,MAAM,KAAKZ,QAAL,EAA5B,CAAP;AACH,KA5FsB,CAAvB;AA8FA,WAAO,KAAKW,eAAZ;AACH;;AA5L2D","sourcesContent":["import { EventEmitter } from 'events';\nimport amqp from 'amqplib';\nimport urlUtils from 'url';\n\nimport ChannelWrapper from './ChannelWrapper';\nimport { wait } from './helpers';\nimport pb from 'promise-breaker';\n\n// Default heartbeat time.\nconst HEARTBEAT_IN_SECONDS = 5;\n\n/* istanbul ignore next */\nfunction neverThrows() {\n    return err =>\n        setImmediate(() => {\n            throw new Error(`AmqpConnectionManager - should never get here: ${err.message}\\n` +\n                err.stack);\n        });\n}\n\n//\n// Events:\n// * `connect({connection, url})` - Emitted whenever we connect to a broker.\n// * `disconnect({err})` - Emitted whenever we disconnect from a broker.\n//\nexport default class AmqpConnectionManager extends EventEmitter {\n    /**\n     *  Create a new AmqplibConnectionManager.\n     *\n     * @param {(string|Object)[]} urls - An array of brokers to connect to.\n     *   Takes url strings or objects {url: string, connectionOptions?: object}\n     *   If present, a broker's [connectionOptions] will be used instead\n     *   of [options.connectionOptions] when passed to the amqplib connect method.\n     *   AmqplibConnectionManager will round-robin between them whenever it\n     *   needs to create a new connection.\n     * @param {Object} [options={}] -\n     * @param {number} [options.heartbeatIntervalInSeconds=5] - The interval,\n     *   in seconds, to send heartbeats.\n     * @param {number} [options.reconnectTimeInSeconds] - The time to wait\n     *   before trying to reconnect.  If not specified, defaults to\n     *   `heartbeatIntervalInSeconds`.\n     * @param {Object} [options.connectionOptions] - Passed to the amqplib\n     *   connect method.\n     * @param {function} [options.findServers] - A `fn(callback)` or a `fn()`\n     *   which returns a Promise.  This should resolve to one or more servers\n     *   to connect to, either a single URL or an array of URLs.  This is handy\n     *   when you're using a service discovery mechanism such as Consul or etcd.\n     *   Note that if this is supplied, then `urls` is ignored.\n     */\n    constructor(urls, options = {}) {\n        super();\n        if(!urls && !options.findServers) {\n            throw new Error(\"Must supply either `urls` or `findServers`\");\n        }\n        this._channels = [];\n\n        this._currentUrl = 0;\n        this.connectionOptions = options.connectionOptions;\n\n        this.heartbeatIntervalInSeconds = options.heartbeatIntervalInSeconds || HEARTBEAT_IN_SECONDS;\n        this.reconnectTimeInSeconds = options.reconnectTimeInSeconds || this.heartbeatIntervalInSeconds;\n\n        // There will be one listener per channel, and there could be a lot of channels, so disable warnings from node.\n        this.setMaxListeners(0);\n\n        this._findServers = options.findServers || (() => Promise.resolve(urls));\n\n        this._connect();\n    }\n\n    // `options` here are any options that can be passed to ChannelWrapper.\n    createChannel(options = {}) {\n        const channel = new ChannelWrapper(this, options);\n        this._channels.push(channel);\n        channel.once('close', () => {\n            this._channels = this._channels.filter(c => c !== channel);\n        });\n        return channel;\n    }\n\n    close() {\n        if(this._closed) { return Promise.resolve(); }\n        this._closed = true;\n\n        if(this._cancelRetriesHandler) { \n          this._cancelRetriesHandler();\n          this._cancelRetriesHandler = null;\n        }\n\n        return Promise.resolve(this._connectPromise).then(() => {\n            return Promise.all(this._channels.map(channel => channel.close()))\n            .catch(function() {\n                // Ignore errors closing channels.\n            })\n            .then(() => {\n                this._channels = [];\n                if(this._currentConnection) {\n                    this._currentConnection.removeAllListeners('close');\n                    this._currentConnection.close();\n                }\n                this._currentConnection = null;\n            });\n        });\n    }\n\n    isConnected() {\n        return !!this._currentConnection;\n    }\n\n    _connect() {\n        if (this._connectPromise) {\n            return this._connectPromise;\n        }\n\n        if(this._closed || this.isConnected()) {\n            return Promise.resolve();\n        }\n\n        this._connectPromise = Promise.resolve()\n        .then(() => {\n            if(!this._urls || (this._currentUrl >= this._urls.length)) {\n                this._currentUrl = 0;\n                return pb.callFn(this._findServers, 0, null);\n            } else {\n                return this._urls;\n            }\n        })\n        .then(urls => {\n            if(urls && !Array.isArray(urls)) { urls = [urls]; }\n            this._urls = urls;\n\n            if(!urls || (urls.length === 0)) {\n                throw new Error('amqp-connection-manager: No servers found');\n            }\n\n            // Round robin between brokers\n            const url = urls[this._currentUrl];\n            this._currentUrl++;\n\n            // url can be a string or object {url: string, connectionOptions?: object}\n            const urlString = url.url || url;\n            const connectionOptions = url.connectionOptions || this.connectionOptions;\n\n            let amqpUrl = null;\n\n            if(typeof urlString === \"object\") {\n                amqpUrl = Object.assign({}, url);\n                if(!amqpUrl.heartbeat) {\n                    amqpUrl.heartbeat = this.heartbeatIntervalInSeconds;\n                }\n            }else {\n                amqpUrl = urlUtils.parse(urlString);\n                if(amqpUrl.search) {\n                    amqpUrl.search += `&heartbeat=${this.heartbeatIntervalInSeconds}`;\n                } else {\n                    amqpUrl.search = `?heartbeat=${this.heartbeatIntervalInSeconds}`;\n                }\n                amqpUrl = urlUtils.format(amqpUrl);\n            }\n\n\n            return amqp.connect(amqpUrl, connectionOptions)\n            .then(connection => {\n                this._currentConnection = connection;\n\n                //emit 'blocked' when RabbitMQ server decides to block the connection (resources running low)\n                connection.on('blocked', reason => this.emit('blocked', { reason }));\n\n                connection.on('unblocked', () => this.emit('unblocked'));\n\n                connection.on('error', (/* err */) => {\n                    // if this event was emitted, then the connection was already closed,\n                    // so no need to call #close here\n                    // also, 'close' is emitted after 'error',\n                    // so no need for work already done in 'close' handler\n                });\n\n                // Reconnect if the connection closes\n                connection.on('close', err => {\n                    this._currentConnection = null;\n                    this.emit('disconnect', { err });\n\n                    const handle = wait(this.reconnectTimeInSeconds * 1000);\n                    this._cancelRetriesHandler = handle.cancel;\n\n                    handle\n                      .promise()\n                      .then(() => this._connect())\n                      // `_connect()` should never throw.\n                      .catch(neverThrows);\n                });\n\n                this._connectPromise = null;\n                this.emit('connect', { connection, url: urlString });\n\n                return null;\n            });\n        })\n        .catch(err => {\n            this.emit('disconnect', { err });\n\n            // Connection failed...\n            this._currentConnection = null;\n            this._connectPromise = null;\n\n            // TODO: Probably want to try right away here, especially if there are multiple brokers to try...\n            const handle = wait(this.reconnectTimeInSeconds * 1000);\n            this._cancelRetriesHandler = handle.cancel;\n\n            return handle.promise().then(() => this._connect());\n        });\n\n        return this._connectPromise;\n    }\n}\n"],"file":"AmqpConnectionManager.js"}