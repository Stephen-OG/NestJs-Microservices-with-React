{"version":3,"sources":["../src/ChannelWrapper.js"],"names":["ChannelWrapper","EventEmitter","addSetup","setup","done","pb","addCallback","_settingUp","Promise","resolve","then","_setups","push","_channel","call","undefined","removeSetup","teardown","filter","s","waitForConnect","once","publish","exchange","routingKey","content","options","reject","_messages","type","_startWorker","sendToQueue","queue","constructor","connectionManager","_onConnect","bind","_onDisconnect","_connectionManager","name","context","_json","json","_unconfirmedMessages","_irrecoverableCode","_irrecoverableError","_working","_workerNumber","isConnected","connection","_currentConnection","on","_connection","createConfirmChannel","channel","_onChannelClose","all","map","setupFn","catch","err","emit","length","shift","ex","Error","code","queueLength","close","forEach","message","removeListener","answer","_shouldPublish","_publishQueuedMessages","_canWaitReconnection","includes","workerNumber","encodedMessage","Buffer","from","JSON","stringify","sendPromise","result","setImmediate","removeUnconfirmedMessage","unshift","ack","apply","arguments","ackAll","nack","nackAll","purgeQueue","checkQueue","assertQueue","bindQueue","deleteQueue","assertExchange","get","arr","toRemove","indexOf","removed","splice"],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport pb from 'promise-breaker';\n\n/**\n *  Calls to `publish()` or `sendToQueue()` work just like in amqplib, but messages are queued internally and\n * are guaranteed to be delivered.  If the underlying connection drops, ChannelWrapper will wait for a new\n * connection and continue.\n *\n * Events:\n * * `connect` - emitted every time this channel connects or reconnects.\n * * `error(err, {name})` - emitted if an error occurs setting up the channel.\n * * `drop({message, err})` - called when a JSON message was dropped because it could not be encoded.\n * * `close` - emitted when this channel closes via a call to `close()`\n *\n */\nexport default class ChannelWrapper extends EventEmitter {\n    /**\n     *  Adds a new 'setup handler'.\n     *\n     * `setup(channel, [cb])` is a function to call when a new underlying channel is created - handy for asserting\n     * exchanges and queues exists, and whatnot.  The `channel` object here is a ConfigChannel from amqplib.\n     * The `setup` function should return a Promise (or optionally take a callback) - no messages will be sent until\n     * this Promise resolves.\n     *\n     * If there is a connection, `setup()` will be run immediately, and the addSetup Promise/callback won't resolve\n     * until `setup` is complete.  Note that in this case, if the setup throws an error, no 'error' event will\n     * be emitted, since you can just handle the error here (although the `setup` will still be added for future\n     * reconnects, even if it throws an error.)\n     *\n     * Setup functions should, ideally, not throw errors, but if they do then the ChannelWrapper will emit an 'error'\n     * event.\n     *\n     * @param {function} setup - setup function.\n     * @param {function} [done] - callback.\n     * @returns {void | Promise} - Resolves when complete.\n     */\n    addSetup(setup, done=null) {\n        return pb.addCallback(done,\n            (this._settingUp || Promise.resolve())\n            .then(() => {\n                this._setups.push(setup);\n                if(this._channel) {\n                    return pb.call(setup, this, this._channel);\n                } else {\n                    return undefined;\n                }\n            })\n        );\n    }\n\n    /**\n     * Remove a setup function added with `addSetup`.  If there is currently a\n     * connection, `teardown(channel, [cb])` will be run immediately, and the\n     * returned Promise will not resolve until it completes.\n     *\n     * @param {function} setup - the setup function to remove.\n     * @param {function} [teardown] - `function(channel, [cb])` to run to tear\n     *   down the channel.\n     * @param {function} [done] - Optional callback.\n     * @returns {void | Promise} - Resolves when complete.\n     */\n    removeSetup(setup, teardown=null, done=null) {\n        return pb.addCallback(done, () => {\n            this._setups = this._setups.filter(s => s !== setup);\n\n            return (this._settingUp || Promise.resolve())\n            .then(() => this._channel\n                ? pb.call(teardown, this, this._channel)\n                : undefined\n            );\n        });\n    }\n\n    /**\n     * Returns a Promise which resolves when this channel next connects.\n     * (Mainly here for unit testing...)\n     *\n     * @param {function} [done] - Optional callback.\n     * @returns {void | Promise} - Resolves when connected.\n     */\n    waitForConnect(done=null) {\n        return pb.addCallback(done,\n            (this._channel && !this._settingUp)\n                ? Promise.resolve()\n                : new Promise(resolve => this.once('connect', resolve))\n        );\n    }\n\n    /*\n     * Publish a message to the channel.\n     *\n     * This works just like amqplib's `publish()`, except if the channel is not\n     * connected, this will wait until the channel is connected.  Returns a\n     * Promise which will only resolve when the message has been succesfully sent.\n     * The returned promise will be rejected if `close()` is called on this\n     * channel before it can be sent, if `options.json` is set and the message\n     * can't be encoded, or if the broker rejects the message for some reason.\n     *\n     */\n    publish(exchange, routingKey, content, options, done=null) {\n        return pb.addCallback(done, new Promise((resolve, reject) => {\n            this._messages.push({\n                type: 'publish',\n                exchange,\n                routingKey,\n                content,\n                options,\n                resolve,\n                reject\n            });\n            this._startWorker();\n        }));\n    }\n\n    /*\n     * Send a message to a queue.\n     *\n     * This works just like amqplib's `sendToQueue`, except if the channel is not connected, this will wait until the\n     * channel is connected.  Returns a Promise which will only resolve when the message has been succesfully sent.\n     * The returned promise will be rejected only if `close()` is called on this channel before it can be sent.\n     *\n     * `message` here should be a JSON-able object.\n     */\n    sendToQueue(queue, content, options, done=null) {\n        return pb.addCallback(done, new Promise((resolve, reject) => {\n            this._messages.push({\n                type: 'sendToQueue',\n                queue,\n                content,\n                options,\n                resolve,\n                reject\n            });\n            return this._startWorker();\n        }));\n    }\n\n    /**\n     * Create a new ChannelWrapper.\n     *\n     * @param {AmqpConnectionManager} connectionManager - connection manager which\n     *   created this channel.\n     * @param {Object} [options] -\n     * @param {string} [options.name] - A name for this channel.  Handy for debugging.\n     * @param {function} [options.setup] - A default setup function to call.  See\n     *   `addSetup` for details.\n     * @param {boolean} [options.json] - if true, then ChannelWrapper assumes all\n     *   messages passed to `publish()` and `sendToQueue()` are plain JSON objects.\n     *   These will be encoded automatically before being sent.\n     *\n     */\n    constructor(connectionManager, options = {}) {\n        super();\n        this._onConnect = this._onConnect.bind(this);\n        this._onDisconnect = this._onDisconnect.bind(this);\n        this._connectionManager = connectionManager;\n        this.name = options.name;\n\n        this.context = {};\n\n        this._json = ('json' in options) ? options.json : false;\n\n        // Place to store queued messages.\n        this._messages = [];\n\n        // Place to store published, but not yet confirmed messages\n        this._unconfirmedMessages = [];\n\n        // Place to store reason code during publish or sendtoqueue messages.\n        this._irrecoverableCode = null;\n        // Irrecoverable error.\n        this._irrecoverableError = [\n          403, // AMQP Access Refused Error.\n          404, // AMQP Not Found Error.\n          406, // AMQP Precondition Failed Error.\n          501, // AMQP Frame Error.\n          502, // AMQP Frame Syntax Error.\n          503, // AMQP Invalid Command Error.\n          504, // AMQP Channel Not Open Error.\n          505, // AMQP Unexpected Frame.\n          530, // AMQP Not Allowed Error.\n          540, // AMQP Not Implemented Error.\n          541, // AMQP Internal Error.\n        ];\n\n        // True if the \"worker\" is busy sending messages.  False if we need to\n        // start the worker to get stuff done.\n        this._working = false;\n\n        // If we're in the process of creating a channel, this is a Promise which\n        // will resolve when the channel is set up.  Otherwise, this is `null`.\n        this._settingUp = null;\n\n        // The currently connected channel.  Note that not all setup functions\n        // have been run on this channel until `@_settingUp` is either null or\n        // resolved.\n        this._channel = null;\n\n        // We kill off workers when we disconnect.  Whenever we start a new\n        // worker, we bump up the `_workerNumber` - this makes it so if stale\n        // workers ever do wake up, they'll know to stop working.\n        this._workerNumber = 0;\n\n        // Array of setup functions to call.\n        this._setups = [];\n        if(options.setup) {\n            this._setups.push(options.setup);\n        }\n\n        if(connectionManager.isConnected()) {\n            this._onConnect({\n                connection: this._connectionManager._currentConnection\n            });\n        }\n        connectionManager.on('connect', this._onConnect);\n        connectionManager.on('disconnect', this._onDisconnect);\n    }\n\n    // Called whenever we connect to the broker.\n    _onConnect({ connection }) {\n        this._connection = connection;\n        this._irrecoverableCode = null;\n\n        return connection.createConfirmChannel()\n        .then(channel => {\n            this._channel = channel;\n            channel.on('close', () => this._onChannelClose(channel));\n\n            this._settingUp = Promise.all(\n                this._setups.map(setupFn =>\n                    // TODO: Use a timeout here to guard against setupFns that never resolve?\n                    pb.call(setupFn, this, channel)\n                    .catch(err => {\n                        if(this._channel) {\n                            this.emit('error', err, { name: this.name });\n                        } else {\n                            // Don't emit an error if setups failed because the channel was closing.\n                        }\n                    })\n                )\n\n            )\n            .then(() => {\n                this._settingUp = null;\n                return this._channel;\n            });\n\n            return this._settingUp;\n        })\n        .then(() => {\n            if(!this._channel) {\n                // Can happen if channel closes while we're setting up.\n                return;\n            }\n            if (this._unconfirmedMessages.length > 0) {\n                // requeu any messages that were left unconfirmed when connection was lost\n                while (this._unconfirmedMessages.length) {\n                    this._messages.push(this._unconfirmedMessages.shift());\n                }\n            }\n\n            // Since we just connected, publish any queued messages\n            this._startWorker();\n            this.emit('connect');\n        })\n        .catch(err => {\n            this.emit('error', err, { name: this.name });\n            this._settingUp = null;\n            this._channel = null;\n        });\n    }\n\n    // Called whenever the channel closes.\n    _onChannelClose(channel) {\n        if(this._channel === channel) {\n            this._channel = null;\n        }\n    }\n    // Wait for another reconnect to create a new channel.\n\n    // Called whenever we disconnect from the AMQP server.\n    _onDisconnect(ex) {\n        this._irrecoverableCode = ((ex.err instanceof Error) ? ex.err.code : null) || null;\n        this._channel = null;\n        this._settingUp = null;\n\n        // Kill off the current worker.  We never get any kind of error for messages in flight - see\n        // https://github.com/squaremo/amqp.node/issues/191.\n        this._working = false;\n    }\n\n    // Returns the number of unsent messages queued on this channel.\n    queueLength() {\n        return this._messages.length;\n    }\n\n    // Destroy this channel.\n    //\n    // Any unsent messages will have their associated Promises rejected.\n    //\n    close() {\n        return Promise.resolve()\n        .then(() => {\n            this._working = false;\n            if(this._messages.length !== 0) {\n                // Reject any unsent messages.\n                this._messages.forEach(message => message.reject(new Error('Channel closed')));\n            }\n            if(this._unconfirmedMessages.length !== 0) {\n                // Reject any unconfirmed messages.\n                this._unconfirmedMessages.forEach(message => message.reject(new Error('Channel closed')));\n            }\n\n            this._connectionManager.removeListener('connect', this._onConnect);\n            this._connectionManager.removeListener('disconnect', this._onDisconnect);\n            const answer = (this._channel && this._channel.close()) || undefined;\n            this._channel = null;\n\n            this.emit('close');\n\n            return answer;\n        });\n    }\n\n    _shouldPublish() {\n        return (this._messages.length > 0) && !this._settingUp && this._channel;\n    }\n\n    // Start publishing queued messages, if there isn't already a worker doing this.\n    _startWorker() {\n        if(!this._working && this._shouldPublish()) {\n            this._working = true;\n            this._workerNumber++;\n            this._publishQueuedMessages(this._workerNumber);\n        }\n    }\n\n    // Define if a message can cause irrecoverable error\n    _canWaitReconnection() {\n      return ! this._irrecoverableError.includes(this._irrecoverableCode);\n    }\n\n    _publishQueuedMessages(workerNumber) {\n        if(!this._shouldPublish() || !this._working || (workerNumber !== this._workerNumber)) {\n            // Can't publish anything right now...\n            this._working = false;\n            return Promise.resolve();\n        }\n\n        const channel = this._channel;\n        const message = this._messages.shift();\n        this._unconfirmedMessages.push(message);\n\n        Promise.resolve()\n        .then(() => {\n            const encodedMessage = this._json ? new Buffer.from(JSON.stringify(message.content)) : message.content;\n\n            const sendPromise = (() => {\n                switch (message.type) {\n                    case 'publish':\n                        return new Promise(function(resolve, reject) {\n                            const result = channel.publish(message.exchange, message.routingKey, encodedMessage,\n                                message.options,\n                                err => {\n                                    if(err) {\n                                        reject(err);\n                                    } else {\n                                        setImmediate(() => resolve(result));\n                                    }\n                                });\n                        });\n                    case 'sendToQueue':\n                        return new Promise(function(resolve, reject) {\n                            const result = channel.sendToQueue(message.queue, encodedMessage, message.options, err => {\n                                if(err) {\n                                    reject(err);\n                                } else {\n                                    setImmediate(() => resolve(result));\n                                }\n                            });\n                        });\n\n                    /* istanbul ignore next */\n                    default:\n                        throw new Error(`Unhandled message type ${message.type}`);\n                }\n            })();\n\n            // Send some more!\n            this._publishQueuedMessages(workerNumber);\n\n            return sendPromise;\n        })\n        .then(\n            result => {\n                removeUnconfirmedMessage(this._unconfirmedMessages, message);\n                message.resolve(result);\n            },\n\n            err => {\n                if(!this._channel && this._canWaitReconnection()) {\n                    // Tried to write to a closed channel.  Leave the message in the queue and we'll try again when we\n                    // reconnect.\n                    removeUnconfirmedMessage(this._unconfirmedMessages, message);\n                    this._messages.unshift(message);\n                } else {\n                    // Something went wrong trying to send this message - could be JSON.stringify failed, could be the\n                    // broker rejected the message.  Either way, reject it back\n                    removeUnconfirmedMessage(this._unconfirmedMessages, message);\n                    message.reject(err);\n                }\n            }\n        )\n        .catch( /* istanbul ignore next */ err => {\n            this.emit('error', err);\n            this._working = false;\n        });\n\n        return null;\n    }\n\n    // Send an `ack` to the underlying channel.\n    ack() {\n        return this._channel && this._channel.ack.apply(this._channel, arguments);\n    }\n\n    // Send an `ackAll` to the underlying channel.\n    ackAll() {\n        return this._channel && this._channel.ackAll.apply(this._channel, arguments);\n    }\n\n    // Send a `nack` to the underlying channel.\n    nack() {\n        return this._channel && this._channel.nack.apply(this._channel, arguments);\n    }\n\n    // Send a `nackAll` to the underlying channel.\n    nackAll() {\n        return this._channel && this._channel.nackAll.apply(this._channel, arguments);\n    }\n\n    // Send a `purgeQueue` to the underlying channel.\n    purgeQueue() {\n        return this._channel && this._channel.purgeQueue.apply(this._channel, arguments);\n    }\n\n    // Send a `checkQueue` to the underlying channel.\n    checkQueue() {\n        return this._channel && this._channel.checkQueue.apply(this._channel, arguments);\n    }\n\n    // Send a `assertQueue` to the underlying channel.\n    assertQueue() {\n        return this._channel && this._channel.assertQueue.apply(this._channel, arguments);\n    }\n\n    // Send a `bindQueue` to the underlying channel.\n    bindQueue() {\n        return this._channel && this._channel.bindQueue.apply(this._channel, arguments);\n    }\n\n    // Send a `deleteQueue` to the underlying channel.\n    deleteQueue() {\n        return this._channel && this._channel.deleteQueue.apply(this._channel, arguments);\n    }\n\n    // Send a `assertExchange` to the underlying channel.\n    assertExchange() {\n        return this._channel && this._channel.assertExchange.apply(this._channel, arguments);\n    }\n\n    // Send a `get` to the underlying channel.\n    get() {\n        return this._channel && this._channel.get.apply(this._channel, arguments);\n    }\n}\n\nfunction removeUnconfirmedMessage(arr, message) {\n    const toRemove = arr.indexOf(message);\n    if (toRemove === -1) {\n        throw new Error(`Message is not in _unconfirmedMessages!`);\n    }\n    const removed = arr.splice(toRemove, 1);\n    return removed[0];\n}"],"file":"ChannelWrapper.js"}